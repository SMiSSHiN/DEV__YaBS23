# gRPC



## Оригинал лекции
Оригинал лекции см. по [ссылке](https://www.youtube.com/watch?v=hulzz2lnR34&t=512s) на *YouTube*.



## Полезные материалы
Материалы с кодом к лекции по [ссылке](https://github.com/r4start/sign-service) на *Github*.



## *Overview*
Последние двадцать лет новые технологии, предназначенные для взаимодействия сервисов по *HTTP*, появляются в один и тот же (не очень большой промежуток времени) ~1-3 года с паузами в ~5-10 лет. Например: *JSON-RPC* (2005), *ODATA* (2007), *OpenAPI* (2011) -> *GraphQL* (2015), *gRPC* (2016).



## Особенности *gRPC*
Форматы передачи данных:
1. *Unary*;
2. *Client Streaming*;
3. *Server Streaming*;
4. *Bidirectional Streaming*.

Особенности *gRPC*:
1. *IDL* на основе *protocol buffers v3*;
2. В *protobuf* сообщения кодируются при помощи способа *tlv (tag-length-value)*, так не нужно посылать имя поля (как в *json*), ведь все поля в *protobuf* просто пронумерованы. За счет чего достигается экономия места в памяти;
3. Достигается экономия *CPU*, т.к. нет необходимости в сериализации/десериализации данных;
4. *Unary* и *Streaming* форматы взаимодейтсвия;
5.  *HTTP/2* в качестве транспортного протокола;
6. Генерация клиента из коробки;
7. Гетерогенность инфраструктуры.



## Сервис подписки
Утилиты для тестирования *grpc*, чтобы была возможность выполнть *list* необходимо включить *reflection.Register(server)*:
```bash
$ grpccurl -plaintext localhost:10116 list
$ grpccurl -plaintext localhost:10116 describe
```

Для *Go* у *grpc message* по умолчанию стоит ограничение на 1Мб, которое опциональньно можно расширить хоть до 1Гб. Тем не менее это не самое лучшее решение, поэтому стоит использовать *Streaming* (без рассмотрения проблем, возникающих при масштабировании). Пример обявления методов *Bidirectional Streaming*:
```golang
    rpc SignStream(stream Document) returns (stream DocSign);
    rpc VerifyStream(stream VerifyRequest) returns (stream VerifyResponse);
```


### *Interceptors*
*Interceptors* в *Golang* - это функции или методы, которые могут быть применены для перехвата и обработки запросов перед их отправкой или после получения ответа. Они используются для добавления дополнительных операций, таких как аутентификация, авторизация, логирование, мониторинг или обработка ошибок.

*Interceptors* могут быть применены к клиентским запросам или серверным методам. Для клиентского запроса, *interceptor* позволяет модифицировать или проверить запрос перед отправкой на сервер или модифицировать ответ перед его возвратом клиенту. Для серверных методов, *interceptor* может проверить или модифицировать запрос перед его обработкой сервером или модифицировать ответ перед его отправкой клиенту.


### Интеграция с *frontend*. *Serving HTTP*
*REST API* удобнее использовать в качестве публичного интерфейса для взаимодействия с *frontend*.

*gRPC* по умолчанию использует протокол *HTTP/2* для передачи бинарных данных, которые могут быть несовместимы с некоторыми *HTTP/1.1* клиентами или серверами. *Serving HTTP* позволяет *gRPC* серверам принимать *HTTP/1.1* запросы, совместимые с обычными *REST API*, таким образом повышая совместимость. Это также позволяет разворачивать и тестировать *gRPC* сервисы в средах, которые еще не поддерживают *HTTP/2*.
